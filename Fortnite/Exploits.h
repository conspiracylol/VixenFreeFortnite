#pragma once
#include <Memory/Hook.h>

struct ReticlePair
{
	unsigned short TableValue;
	unsigned short TableOffset;
};

namespace Exploits
{
	void Tick( APlayerController* PlayerController)
	{
		if ( PlayerController )
		{
			static APlayerController* OldPlayerController = nullptr;
			static APlayerCameraManager* OldPlayerCameraManager = nullptr;


			if (Settings::Developer::FreecamHook2)
			{
				if (PlayerController != OldPlayerController)
				{

					bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerController, Classes::PlayerController);
					if (PlayerCameraManagerIsA)
					{
						Hook::VTableHook().Hook(PlayerController, GetPlayerViewPoint, Offsets::GetPlayerViewPoint, &GetPlayerViewPointOriginal);
					}

					OldPlayerController = PlayerController;
				}
			}

			if (Settings::Developer::FreecamHook2)
			{
				if (APlayerCameraManager* PlayerCameraManager = PlayerController->PlayerCameraManager())
				{
					if (PlayerCameraManager != OldPlayerCameraManager)
					{
						bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerCameraManager, Classes::PlayerCameraManager);
						if (PlayerCameraManagerIsA)
						{
							Hook::VTableHook().Hook(PlayerCameraManager, GetCameraViewPoint, Offsets::GetCameraViewPoint, &GetCameraViewPointOriginal);

							OldPlayerCameraManager = PlayerCameraManager;
						}
					}
				}
			}

			if (Settings::Developer::Debugging::StaticStickyViewpoint)
			{
				if (APlayerCameraManager* PlayerCameraManager = PlayerController->PlayerCameraManager())
				{
					if (Settings::Developer::FreecamTest)
					{
						if (!Settings::Developer::FreecamTestHook2)
						{
							if (PlayerCameraManager != OldPlayerCameraManager)
							{
								bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerCameraManager, Classes::PlayerCameraManager);
								if (PlayerCameraManagerIsA)
								{
									Hook::VTableHook().Hook(PlayerCameraManager, &GetPlayerViewPoint, Offsets::GetPlayerViewPoint, &GetPlayerViewPointOriginal);

									OldPlayerCameraManager = PlayerCameraManager;
								}
							}
						}
						else
						{
							if (PlayerCameraManager != OldPlayerCameraManager)
							{
								bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerCameraManager, Classes::PlayerCameraManager);
								if (PlayerCameraManagerIsA)
								{
									Hook::VTableHook().Hook(PlayerCameraManager, &GetPlayerViewPoint, Offsets::GetPlayerViewPointTest, &GetPlayerViewPointOriginal);

									OldPlayerCameraManager = PlayerCameraManager;
								}
							}
						}
					}
				}
			}

			if (Settings::Developer::Debugging::StaticStickyViewpoint)
			{
				if (APlayerCameraManager* PlayerCameraManager = PlayerController->PlayerCameraManager())
				{
					if (Settings::Developer::FreecamTest)
					{
						if (!Settings::Developer::FreecamTestHook2)
						{
							if (PlayerCameraManager != OldPlayerCameraManager)
							{
								bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerCameraManager, Classes::PlayerCameraManager);
								if (PlayerCameraManagerIsA)
								{
									Hook::VTableHook().Hook(PlayerCameraManager, &GetCameraViewPoint, Offsets::GetCameraViewPoint, &GetCameraViewPointOriginal);

									OldPlayerCameraManager = PlayerCameraManager;
								}
							}
						}
						else
						{
							if (PlayerCameraManager != OldPlayerCameraManager)
							{
								bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(PlayerCameraManager, Classes::PlayerCameraManager);
								if (PlayerCameraManagerIsA)
								{
									Hook::VTableHook().Hook(PlayerCameraManager, &GetCameraViewPoint, Offsets::GetCameraViewPointTest, &GetCameraViewPointOriginal);

									OldPlayerCameraManager = PlayerCameraManager;
								}
							}
						}
					}
				}
			}


			static bool Update_FieldOfView = false;
			if ( Settings::Exploits::CameraFOVChanger )
			{
				PlayerController->FOV( static_cast< float >( Settings::Exploits::CameraFOV ) );
				Update_FieldOfView = true;
			}
			else
			{
				if ( Update_FieldOfView )
				{
					PlayerController->FOV( 0.f );
					Update_FieldOfView = false;
				}
			}

			if ( Settings::Exploits::NoRecoil )
			{
				*( BYTE* ) ( FortniteClientWin64Shipping + Offsets::bEnableRecoilDelay) = false;
			}

			bool DoExploits = Settings::Exploits::SilentAimbot || Settings::Exploits::ShootThroughWalls || Settings::Exploits::NoSpread || Settings::Exploits::HitSound;
			if ( DoExploits )
			{ 
				APlayerPawn_Athena_C* AcknowledgedPawn = PlayerController->AcknowledgedPawn( );
				if ( AcknowledgedPawn )
				{
					AFortWeapon* CurrentWeapon = AcknowledgedPawn->CurrentWeapon( );
					if ( CurrentWeapon )
					{
						bool CurrentWeaponIsARanged = StaticClasses::GameplayStatics->ObjectIsA( CurrentWeapon , Classes::FortWeaponRanged );
						if ( CurrentWeaponIsARanged )
						{
							bool IsHoldingPickaxe = StaticClasses::GameplayStatics->ObjectIsA( CurrentWeapon , Classes::WeaponPickaxeAthena );
							if ( !IsHoldingPickaxe )
							{
								/*if (CurrentWeapon)
								{
									Hook::VTableHook().Hook( CurrentWeapon , HasInfiniteAmmo , 299 , &HasInfiniteAmmoOrignal );

									UObject* SomePointer = CurrentWeapon->WeaponData();
									if ( SomePointer )
									{
										Hook::VTableHook( ).Hook( SomePointer , HasInfiniteReserveAmmo , 17 , &HasInfiniteReserveAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteMagazineAmmo , 18 , &HasInfiniteMagazineAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesChargesForAmmo , 19 , &UsesChargesForAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteCharges , 20 , &HasInfiniteChargesOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesEnergyPoolForAmmo , 21 , &UsesEnergyPoolForAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteEnergyPool , 22 , &HasInfiniteEnergyPoolOrignal );
										Hook::VTableHook().Hook( SomePointer , UsesConsumableAmmo , 23 , &UsesConsumableAmmoOrignal );
										Hook::VTableHook().Hook( SomePointer , HasInfiniteConsumables , 24 , &HasInfiniteConsumablesOrignal );
										Hook::VTableHook().Hook( SomePointer , InventoryOwnerHasInfiniteAmmo , 25 , &InventoryOwnerHasInfiniteAmmoOrignal );
									}
								}

								if ( Settings::Exploits::NoSpread )
								{
									auto ZeroReticle = [ ]( AFortWeapon* CurrentWeapon , unsigned short ValueOffset , unsigned short TableOffset )
										{
											auto ValueIndex = *( unsigned char* ) ( CurrentWeapon + TableOffset + 1 ) - ValueOffset;
											auto TableIndex = *( unsigned char* ) ( CurrentWeapon + TableOffset );
											auto TableEntry = ( CurrentWeapon + TableIndex * sizeof( unsigned long ) + TableOffset - 0x10 );

											auto SpreadKey = ValueIndex & 0x82FFFFFE | 0x4C000001;
											auto TableValue = *( int* ) ( TableEntry );

											auto SpreadUInt = SpreadKey ^ TableValue;
											auto CurrentSpread = *( float* ) ( &SpreadUInt );

											if ( CurrentSpread < 0.0f )
											{
												return;
											}

											float Value = 0.135f;
											auto RealValue = *( int* ) ( &Value ) ^ SpreadKey;
											*( int* ) ( TableEntry ) = RealValue;
										};

									static const ReticlePair Pairs[ ]
									{
										{ 0xA1D2, 0x1BC6 },
										{ 0xE572, 0x1BD8 },
										{ 0xE572, 0x1B62 },
										{ 0xE572, 0x1B74 },
										{ 0xE572, 0x1B86 },
										{ 0xE572, 0x1B98 },
									};

									for ( auto& RetPair : Pairs )
									{
										ZeroReticle( CurrentWeapon , RetPair.TableValue , RetPair.TableOffset );
									}
								}*/

								static AFortWeapon* OldCurrentWeapon = nullptr;
								if ( CurrentWeapon != OldCurrentWeapon )
								{
									
									if ((Settings::Exploits::SilentAimbot || (Variables::BulletTraces::bEnableBulletTraces && !Settings::Exploits::SilentAimbot)))
									{
										if (!Settings::Developer::FreecamTestHook2)
										{
											Hook::VTableHook().Hook(CurrentWeapon, GetWeaponTargetingTransform, Offsets::GetWeaponTargetingTransform, &GetWeaponTargetingTransformOriginal);
											if (Settings::Exploits::SilentHookV2)
											{
												Hook::VTableHook().Hook(CurrentWeapon, GetDamageStartLocation, Offsets::GetDamageStartLocation, &GetDamageStartLocationOriginal);
											}
										}
										else
										{
											Hook::VTableHook().Hook(CurrentWeapon, GetWeaponTargetingTransform, Offsets::GetWeaponTargetingTransformTest, &GetWeaponTargetingTransformOriginal);
											
											if (Settings::Exploits::SilentHookV2)
											{
												Hook::VTableHook().Hook(CurrentWeapon, GetDamageStartLocation, Offsets::GetDamageStartLocationTest, &GetDamageStartLocationOriginal);
											}
										}
									}

									if (Variables::BulletTraces::bEnableBulletTraces && (Settings::Developer::bTraceV2Hook))
									{
										Hook::VTableHook().Hook(CurrentWeapon, &FireSingle, Offsets::FireSingle, &FireSingleOriginal);
										Hook::VTableHook().Hook(CurrentWeapon, &TryToFire, Offsets::TryToFire, &TryToFireOriginal);
									}

									if (Settings::Exploits::ShootThroughWalls)
									{
										Hook::VTableHook().Hook( CurrentWeapon , DetermineTraceChannel , Offsets::DetermineTraceChannel , &DetermineTraceChannelOriginal );
									}

									OldCurrentWeapon = CurrentWeapon;
								}
							}
						}
					}
				}
			}
		}

	}

	void TickP( ULocalPlayer* LocalPlayer)
	{
		if (LocalPlayer)
		{
			static ULocalPlayer* OldLocalPlayer = nullptr;

			if (Settings::Developer::FreecamHook2)
			{
				if (LocalPlayer != OldLocalPlayer)
				{
					bool PlayerCameraManagerIsA = StaticClasses::GameplayStatics->ObjectIsA(OldLocalPlayer, Classes::LocalPlayer);
					if (PlayerCameraManagerIsA)
					{
						Hook::VTableHook().Hook(LocalPlayer, GetPlayerViewPoint, Offsets::GetPlayerViewPoint, &GetPlayerViewPointOriginal);
					}

					OldLocalPlayer = LocalPlayer;
				}
			}
		}

	}

	void TickPlayer()
	{
		return;

		//void GetViewPoint(ULocalPlayer * LocalPlayer, FMinimalViewInfo * OutViewInfo, void* StereoPass)
		// 	static void* (*StaticFindObject)(UObject * Class, UObject * InOuter, const wchar_t* Name, bool ExactClass) = nullptr;
		static void (*GetViewPoint)(ULocalPlayer* LocalPlayer, FMinimalViewInfo* OutViewInfo, void* StereoPass) = nullptr;

		if (!GetViewPoint)
		{

			GetViewPoint = find_pattern<decltype(GetViewPoint)>("4C 8B DC 49 89 5B 20 55 56 57 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 84 24 ? ? ? ? 41 0F");

			//WindowsAPI::MessageBoxA(0, std::to_string(std::uintptr_t(StaticFindObject)).c_str(), "StaticFind", 0x40);
			//WindowsAPI::MessageBoxA(0, std::to_string(std::uintptr_t(( (uintptr_t)StaticFindObject - FortniteClientWin64Shipping))).c_str(), "StaticFindOffset", 0x40);
		}

		if (!GetViewPoint)
		{
			WindowsAPI::MessageBoxA(0, Encrypt("GetViewPoint failed.").decrypt(), 0, 0);
		}
		else
		{
			WindowsAPI::MessageBoxA(0, Encrypt("GetViewPoint success.").decrypt(), 0, 0);
			TrampolineHook((BYTE*)GetViewPoint, (BYTE*)GetViewPointOriginal, 5);
		}
		
		// "4C 8B DC 49 89 5B 20 55 56 57 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 84 24 ? ? ? ? 41 0F"
	}
}
